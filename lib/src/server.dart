import 'dart:async' show Future, Stream, StreamController;
import 'dart:convert' show UTF8;
import 'dart:io' as io;
import 'package:meta/meta.dart';
import 'package:logging/logging.dart' show Logger, Level;

final _log = new Logger('bwu_datastore_launcher.server');

/// A common base class for different server implemantations.
abstract class Server {
  /// The working directory to passed to [io.Process.start]
  String workingDirectory;

  /// Environment variables to passed to [io.Process.start]
  Map<String, String> environment;

  /// A list of command line arguments passed between the [exePath] and the
  /// other parameters generated by [Server].
  List<String> parameters;

  String _exePath;

  /// The path to the `gcloud` executable
  String get exePath => _exePath;

  /// Set the path for the `gcloud` executable
  @protected
  set exePath(String value) => this._exePath = value;

  io.InternetAddress _host;

  /// The network interface the server binds to.
  io.InternetAddress get host => _host;

  /// Set the network interface for the server to bind to.
  @protected
  set host(io.InternetAddress value) => this._host = value;

  int _port;

  /// The network port the server listens to.
  // ignore: unnecessary_getters_setters
  int get port => _port;

  /// Set the network port the server should listen to.
  @protected
  // ignore: unnecessary_getters_setters
  set port(int value) => _port = value;

  /// Creates an URL from the host and port arguments.
  String get url {
    if (host != null) {
      if (host.type == io.InternetAddressType.IP_V6) {
        return 'http://[${_host.address}]:${_port}/';
      } else {
        return 'http://${_host.address}:${_port}/';
      }
    }
    return null;
  }

  /// The directory to use for the datastore data.
  /// This is required by gcd even when `--store_to_disk=false`
  final String datastoreDirectory;

  io.Process _process;

  /// The reference to the running server process.
  @protected
  io.Process get process => _process;

  /// Returns `true` when the server instance was started, `false` otherwise.
  bool get isRunning => _process != null;

  int _exitCode;

  /// Returns the exit code reported by the server executable when it
  /// terminated.
  int get exitCode => _exitCode;

  /// Wait at least [startupDelay] time before [start] returns to ensure the
  /// server is up and ready.
  Duration startupDelay;

  DateTime _startTime;

  /// The timestamp when the executable was run.
  DateTime get startTime => _startTime;

  /// Notify when the launched command exits.
  StreamController<int> _exitController = new StreamController<int>();
  Stream<int> _exitStream;

  /// Subscribe to get notified when the server process ends.
  Stream<int> get onExit => _exitStream;

  /// Create a new server instance.
  /// TODO(zoechi) document
  Server(this.datastoreDirectory,
      {this.workingDirectory,
      this.environment,
      this.parameters,
      this.startupDelay}) {
    _exitStream = _exitController.stream.asBroadcastStream();
    if (workingDirectory == null) {
      workingDirectory = io.Directory.current.path;
    }
  }

  /// End the server process.
  Future<bool> shutdown() {
    throw '"shutdown" is not implemented';
  }

  /// Kill the server process.
  Future<bool> kill(
      [io.ProcessSignal signal = io.ProcessSignal.SIGTERM]) async {
    if (_process == null) {
      return false;
    } else {
      _log.finer('kill ${_process.pid}: ${signal}');
      return _process.kill(signal);
    }
  }

  /// Launch the server process according to the configured options.
  Future<bool> startProcess(List<String> arguments) async {
    if (_process != null) {
      throw 'Server is already running. Kill it first or create a new AppengineApiServer instance.';
    } else {
      _log.finer('Working directory: ${workingDirectory}');
      _log.finer('Start: ${exePath} ${arguments.join(' ')}');
      _log.finer('Environment: ${environment}');
      _log.finer('exePath: ${_exePath}, arguments: ${arguments}');
      return io.Process
          .start(exePath, arguments,
              workingDirectory: workingDirectory, environment: environment)
          .then((process) {
        _startTime = new DateTime.now();
        _process = process;
        _process
          ..stdout.listen((stdOut) => _log.finer(UTF8.decoder.convert(stdOut)))
          ..stderr.listen((stdErr) {
            final text = UTF8.decoder.convert(stdErr);
            if (text.startsWith('WARN: ')) {
              _log.warning(text);
            } else if (text.startsWith('ERROR: ')) {
              _log.severe(text);
            } else {
              _log.finer(text);
            }
          })
          ..exitCode.then((exitCode) {
            _process = null;
            _exitCode = exitCode;
            _log.finer('\nexit ${_exitCode}');
            _exitController.add(exitCode);
          });
        return true;
      });
    }
    return false;
  }
}
